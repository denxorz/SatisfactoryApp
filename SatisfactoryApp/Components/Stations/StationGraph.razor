@using Denxorz.Satisfactory.Routes.Types
@using Microsoft.JSInterop
@using MudBlazor
@using SatisfactoryApp.Services
@using SatisfactoryApp.Services.Stations
@using SatisfactoryApp.Utils
@using System.Net
@using System.Text
@implements IDisposable
@inject StationStore StationStore
@inject IJSRuntime JSRuntime

<MudCard Outlined="true" Square="true" Class="border-solid border-4 mud-border-primary">
    <MudCardHeader Class="mud-primary pa-0 pl-1">
        <MudText Class="primary-card-header-title" Color="Color.Surface">Map</MudText>
        @if (_isLoading)
        {
            <MudText Typo="Typo.caption" Class="text-uppercase" Color="Color.Surface">Loading...</MudText>
        }
        else if (!string.IsNullOrEmpty(_error))
        {
            <MudText Typo="Typo.caption" Class="text-uppercase" Color="Color.Error">Error: @_error</MudText>
        }
    </MudCardHeader>
    <MudCardContent  Class="pa-0">
        <div class="map-container @_containerCssClass" @onclick="HandleMapClick">
            <div class="map-wrapper @_wrapperCssClass">
                <img src="/images/1920px-Biome_Map.jpg" alt="Biome Map" class="map-image background-only" />
                @if (!string.IsNullOrEmpty(_svgContent))
                {
                    <div class="svg-overlay">
                        @((MarkupString)_svgContent)
                    </div>
                }
            </div>

            <div class="legend-overlay">
                <div class="legend-item">
                    <svg class="legend-icon" viewBox="0 0 16 10" width="20" height="14">
                        <rect x="1" y="1" width="14" height="8" rx="1" fill="#212121" stroke="#e59345" stroke-width="0.8"/>
                    </svg>
                    <span>Station</span>
                </div>
                <div class="legend-item">
                    <svg class="legend-icon" viewBox="0 0 16 14" width="16" height="14">
                        <polygon points="8,1 2,13 14,13" fill="#FF0000" stroke="#e59345" stroke-width="0.8"/>
                    </svg>
                    <span>Uploader</span>
                </div>
            </div>

            @if (_showTooltip && (_selectedStation != null || _selectedUploader != null))
            {
                <div class="factory-tooltip" style="left: @($"{_tooltipX}px"); top: @($"{_tooltipY}px")">
                    <div class="tooltip-content">
                        @if (_selectedStation != null)
                        {
                            <div class="tooltip-header">@(_selectedStation.ShortName ?? _selectedStation.Name ?? "Unknown Station")</div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Name:</span>
                                <span class="tooltip-value">@(_selectedStation.Name ?? "-")</span>
                            </div>
                        }
                        else if (_selectedUploader != null)
                        {
                            <div class="tooltip-header">Uploader</div>
                            @if (_selectedUploader.CargoTypes != null && _selectedUploader.CargoTypes.Count > 0)
                            {
                                <div class="tooltip-row">
                                    <span class="tooltip-label">Cargo:</span>
                                    <span class="tooltip-value">@string.Join(", ", _selectedUploader.CargoTypes)</span>
                                </div>
                            }
                        }
                    </div>
                </div>
            }
        </div>
    </MudCardContent>
</MudCard>

@code {
    private bool _isLoading;
    private string? _error;
    private string? _svgContent;
    private int _lastUpdateCounter = -1;
    private readonly string _containerCssClass = $"map-container-{Guid.NewGuid():N}";
    private readonly string _wrapperCssClass = $"map-wrapper-{Guid.NewGuid():N}";
    private Station? _selectedStation;
    private Uploader? _selectedUploader;
    private bool _showTooltip = false;
    private double _tooltipX = 0;
    private double _tooltipY = 0;

    protected override void OnInitialized()
    {
        StationStore.FilteredStationsChanged += OnFilteredStationsChanged;
    }

    private async void OnFilteredStationsChanged()
    {
        await CheckAndRenderIfNeeded();
    }

    public void Dispose()
    {
        StationStore.FilteredStationsChanged -= OnFilteredStationsChanged;
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        return CheckAndRenderIfNeeded();
    }

    private async Task CheckAndRenderIfNeeded()
    {
        if (StationStore.UpdateCounter != _lastUpdateCounter)
        {
            _lastUpdateCounter = StationStore.UpdateCounter;
            if (!_isLoading && string.IsNullOrEmpty(_error))
                await RenderMap();
        }
    }

    private Task RenderMap()
    {
        try
        {
            _isLoading = true;
            StateHasChanged();
            _svgContent = CreateStationGraphSvg();
            _isLoading = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _error = "Failed to render graph: " + ex.Message;
            _isLoading = false;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    private string CreateStationGraphSvg()
    {
        const int minX = -320000;
        const int maxX = 425000;
        const int minY = -380000;
        const int maxY = 375000;
        const int mapWidth = 30;
        const int mapHeight = 30;

        var scaleX = mapWidth / (double)(maxX - minX);
        var scaleY = mapHeight / (double)(maxY - minY);

        double ToSvgX(double worldX) => (worldX - minX) * scaleX;
        double ToSvgY(double worldY) => (worldY - minY) * scaleY;

        var requiredStations = new HashSet<string>();
        var edges = new List<(string from, string to, string color, string style, int penwidth)>();

        foreach (var station in StationStore.FilteredStations)
        {
            if (station.Transporters == null) continue;

            foreach (var transporter in station.Transporters)
            {
                var fromStation = StationStore.Stations.FirstOrDefault(s => s.Id == transporter.From);
                var toStation = StationStore.Stations.FirstOrDefault(s => s.Id == transporter.To);

                if (fromStation == null || toStation == null) continue;

                var edgeColor = "#FF0000";
                var edgeStyle = "solid";
                var edgePenwidth = 2;

                var stationType = station.Type;
                if (stationType == "drone")
                    edgeStyle = "dashed";
                else if (stationType == "truck")
                {
                    edgeStyle = "dotted";
                    edgePenwidth = 4;
                }

                var cargoTypes = fromStation.CargoTypes ?? new List<string>();
                if (cargoTypes.Count == 0 && fromStation.CargoFlows != null)
                    cargoTypes = fromStation.CargoFlows.Select(cf => cf.Type).ToList();
                if (cargoTypes.Count > 0)
                    edgeColor = CargoColors.GetCargoColor(cargoTypes[0]);

                var fromName = fromStation.ShortName ?? fromStation.Id;
                var toName = toStation.ShortName ?? toStation.Id;
                requiredStations.Add(fromName);
                requiredStations.Add(toName);

                if (fromStation.IsUnload)
                    edges.Add((toName, fromName, edgeColor, edgeStyle, edgePenwidth));
                else
                    edges.Add((fromName, toName, edgeColor, edgeStyle, edgePenwidth));

                if (transporter.OtherStops != null)
                {
                    foreach (var stopId in transporter.OtherStops)
                    {
                        var otherStopStation = StationStore.Stations.FirstOrDefault(s => s.Id == stopId);
                        if (otherStopStation != null)
                        {
                            var otherName = otherStopStation.ShortName ?? otherStopStation.Id;
                            requiredStations.Add(otherName);
                            if (fromStation.IsUnload)
                                edges.Add((toName, otherName, edgeColor, edgeStyle, edgePenwidth));
                            else
                                edges.Add((otherName, toName, edgeColor, edgeStyle, edgePenwidth));
                        }
                    }
                }
            }
        }

        var uniqueEdges = edges.GroupBy(e => (e.from, e.to)).Select(g => g.First()).ToList();
        var uniqueStations = StationStore.Stations
            .Where(s => requiredStations.Contains(s.ShortName ?? s.Id))
            .GroupBy(s => s.ShortName ?? s.Id)
            .Select(g => g.First())
            .ToList();

        var posByStation = uniqueStations.ToDictionary(s => s.ShortName ?? s.Id, s => (x: ToSvgX(s.X), y: ToSvgY(s.Y)));

        const double nodeH = 0.35;
        const double paddingX = 0.22;
        const double charWidth = 0.115;
        var boxByStation = uniqueStations.ToDictionary(s => s.ShortName ?? s.Id, s =>
        {
            var labelLen = (s.ShortName ?? s.Id).Length;
            var nodeW = Math.Max(0.65, paddingX * 2 + labelLen * charWidth);
            return (w: nodeW, h: nodeH);
        });

        string StrokeDasharray(string style) => style switch { "dashed" => "0.2,0.15", "dotted" => "0.08,0.1", _ => "none" };

        var sb = new StringBuilder();
        sb.AppendLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 {mapWidth} {mapHeight}\" preserveAspectRatio=\"none\">");
        sb.AppendLine("  <defs>");
        sb.AppendLine("    <marker id=\"arrow\" markerUnits=\"userSpaceOnUse\" markerWidth=\"0.26\" markerHeight=\"0.26\" refX=\"0.22\" refY=\"0.13\" orient=\"auto\">");
        sb.AppendLine("      <polygon points=\"0,0 0.26,0.13 0,0.26\" fill=\"context-stroke\"/>");
        sb.AppendLine("    </marker>");
        sb.AppendLine("  </defs>");

        const double edgeStroke = 0.04;
        const double edgeStrokeTruck = 0.06;
        foreach (var edge in uniqueEdges)
        {
            if (!posByStation.TryGetValue(edge.from, out var fromPos) || !posByStation.TryGetValue(edge.to, out var toPos))
                continue;
            if (!boxByStation.TryGetValue(edge.from, out var fromBox) || !boxByStation.TryGetValue(edge.to, out var toBox))
                continue;
            var (x1, y1, x2, y2) = ClipLineToBoxes(fromPos.x, fromPos.y, toPos.x, toPos.y, fromBox.w, fromBox.h, toBox.w, toBox.h);
            var dash = StrokeDasharray(edge.style);
            var dashAttr = dash == "none" ? "" : $" stroke-dasharray=\"{dash}\"";
            var strokeW = edge.penwidth == 4 ? edgeStrokeTruck : edgeStroke;
            sb.AppendLine($"  <line x1=\"{x1:F2}\" y1=\"{y1:F2}\" x2=\"{x2:F2}\" y2=\"{y2:F2}\" stroke=\"{edge.color}\" stroke-width=\"{strokeW:F2}\"{dashAttr} fill=\"none\" marker-end=\"url(#arrow)\"/>");
        }

        const double fontSize = 0.22;

        foreach (var station in uniqueStations)
        {
            var name = station.ShortName ?? station.Id;
            if (!posByStation.TryGetValue(name, out var pos))
                continue;
            var label = WebUtility.HtmlEncode((station.ShortName ?? station.Id).ToUpperInvariant());
            var nodeW = Math.Max(0.65, paddingX * 2 + label.Length * charWidth);
            var cx = pos.x;
            var cy = pos.y;
            var left = cx - nodeW / 2;
            var top = cy - nodeH / 2;
            sb.AppendLine($"  <rect x=\"{left:F2}\" y=\"{top:F2}\" width=\"{nodeW:F2}\" height=\"{nodeH}\" fill=\"#212121\" stroke=\"#e59345\" stroke-width=\"0.03\" rx=\"0.05\"/>");
            sb.AppendLine($"  <text x=\"{cx:F2}\" y=\"{cy:F2}\" font-family=\"Arial\" font-size=\"{fontSize}\" font-weight=\"600\" fill=\"#e59345\" text-anchor=\"middle\" dominant-baseline=\"central\" letter-spacing=\"-0.01\">{label}</text>");
        }

        const double triSize = 0.2;
        foreach (var uploader in StationStore.FilteredUploaders)
        {
            var x = ToSvgX(uploader.X);
            var y = ToSvgY(uploader.Y);
            var cargoTypes = uploader.CargoTypes ?? new List<string>();
            var color = cargoTypes.Count > 0 ? CargoColors.GetCargoColor(cargoTypes[0]) : "#FF0000";
            var top = y - triSize / 2;
            var bot = y + triSize / 2;
            var left = x - triSize / 2;
            var right = x + triSize / 2;
            var points = $"{x:F2},{top:F2} {left:F2},{bot:F2} {right:F2},{bot:F2}";
            sb.AppendLine($"  <polygon points=\"{points}\" fill=\"{color}\" stroke=\"#e59345\" stroke-width=\"0.03\"/>");
        }

        sb.AppendLine("</svg>");
        return sb.ToString();
    }

    private static (double x1, double y1, double x2, double y2) ClipLineToBoxes(double fromX, double fromY, double toX, double toY, double fromW, double fromH, double toW, double toH)
    {
        var dx = toX - fromX;
        var dy = toY - fromY;
        var len = Math.Sqrt(dx * dx + dy * dy);
        if (len < 1e-9)
            return (fromX, fromY, toX, toY);

        var tExitFrom = SegmentRectIntersect(fromX, fromY, toX, toY, fromX, fromY, fromW, fromH).Where(t => t > 1e-9).DefaultIfEmpty(0).Min();
        var tEnterTo = SegmentRectIntersect(fromX, fromY, toX, toY, toX, toY, toW, toH).Where(t => t >= 0 && t <= 1).DefaultIfEmpty(1).Min();

        if (tExitFrom >= tEnterTo)
            tExitFrom = 0;
        var startX = fromX + tExitFrom * dx;
        var startY = fromY + tExitFrom * dy;
        var endX = fromX + tEnterTo * dx;
        var endY = fromY + tEnterTo * dy;
        return (startX, startY, endX, endY);
    }

    private static IEnumerable<double> SegmentRectIntersect(double x1, double y1, double x2, double y2, double cx, double cy, double w, double h)
    {
        var hw = w / 2;
        var hh = h / 2;
        var left = cx - hw;
        var right = cx + hw;
        var top = cy - hh;
        var bottom = cy + hh;
        var dx = x2 - x1;
        var dy = y2 - y1;

        if (Math.Abs(dx) > 1e-12)
        {
            var tLeft = (left - x1) / dx;
            var tRight = (right - x1) / dx;
            var yLeft = y1 + tLeft * dy;
            var yRight = y1 + tRight * dy;
            if (tLeft >= 0 && tLeft <= 1 && yLeft >= top && yLeft <= bottom) yield return tLeft;
            if (tRight >= 0 && tRight <= 1 && yRight >= top && yRight <= bottom) yield return tRight;
        }
        if (Math.Abs(dy) > 1e-12)
        {
            var tTop = (top - y1) / dy;
            var tBottom = (bottom - y1) / dy;
            var xTop = x1 + tTop * dx;
            var xBottom = x1 + tBottom * dx;
            if (tTop >= 0 && tTop <= 1 && xTop >= left && xTop <= right) yield return tTop;
            if (tBottom >= 0 && tBottom <= 1 && xBottom >= left && xBottom <= right) yield return tBottom;
        }
    }

    private async Task HandleMapClick(MouseEventArgs e)
    {
        if (string.IsNullOrEmpty(_svgContent)) return;

        var rect = await JSRuntime.InvokeAsync<BoundingClientRect>("getElementBoundingClientRect", $".{_wrapperCssClass}");
        if (rect == null) return;

        var clickX = e.ClientX - rect.Left;
        var clickY = e.ClientY - rect.Top;

        const int minX = -320000;
        const int maxX = 425000;
        const int minY = -380000;
        const int maxY = 375000;

        var scaleX = (maxX - minX) / rect.Width;
        var scaleY = (maxY - minY) / rect.Height;

        var mapX = clickX * scaleX + minX;
        var mapY = clickY * scaleY + minY;

        const int clickRadius = 5000;
        Station? closestStation = null;
        Uploader? closestUploader = null;
        double closestDistance = double.MaxValue;

        var allStations = StationStore.Stations.ToList();
        var allUploaders = StationStore.Uploaders.ToList();

        foreach (var station in allStations)
        {
            var distance = Math.Sqrt(Math.Pow(mapX - station.X, 2) + Math.Pow(mapY - station.Y, 2));
            if (distance < clickRadius && distance < closestDistance)
            {
                closestDistance = distance;
                closestStation = station;
                closestUploader = null;
            }
        }

        foreach (var uploader in allUploaders)
        {
            var distance = Math.Sqrt(Math.Pow(mapX - uploader.X, 2) + Math.Pow(mapY - uploader.Y, 2));
            if (distance < clickRadius && distance < closestDistance)
            {
                closestDistance = distance;
                closestUploader = uploader;
                closestStation = null;
            }
        }

        _selectedStation = closestStation;
        _selectedUploader = closestUploader;

        if (_selectedStation != null || _selectedUploader != null)
        {
            var containerRect = await JSRuntime.InvokeAsync<BoundingClientRect>("getElementBoundingClientRect", $".{_containerCssClass}");
            if (containerRect != null)
            {
                var containerClickX = e.ClientX - containerRect.Left;
                var containerClickY = e.ClientY - containerRect.Top;

                var rawX = containerClickX + 15;
                var rawY = containerClickY - 10;

                const double margin = 8;
                const double tooltipWidth = 260;
                const double tooltipHeight = 100;

                var maxTooltipX = Math.Max(margin, containerRect.Width - tooltipWidth - margin);
                var maxTooltipY = Math.Max(margin, containerRect.Height - tooltipHeight - margin);
                var minTooltipY = margin + tooltipHeight;

                _tooltipX = Math.Min(Math.Max(rawX, margin), maxTooltipX);
                _tooltipY = Math.Min(Math.Max(rawY, minTooltipY), maxTooltipY);
                _showTooltip = true;
            }
        }
        else
        {
            _showTooltip = false;
        }

        StateHasChanged();
    }

    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .map-container {
        position: relative;
        overflow: hidden;
        min-height: 400px;
        cursor: pointer;
    }

    .map-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .map-image {
        object-fit: contain;
        transition: opacity 0.2s;
        width: 100%;
        height: auto;
    }

    .map-image.background-only {
        filter: grayscale(0.4) contrast(0.8) brightness(1.1);
        opacity: 0.4;
    }

    .svg-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .svg-overlay svg {
        width: 100%;
        height: 100%;
    }

    .legend-overlay {
        position: absolute;
        bottom: 16px;
        right: 16px;
        background: rgba(10, 10, 10, 0.65);
        border: 1px solid #e59345;
        border-radius: 6px;
        padding: 8px 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 170px;
        backdrop-filter: blur(4px);
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #f5f5f5;
    }

    .legend-icon {
        display: block;
        flex-shrink: 0;
    }

    .factory-tooltip {
        position: absolute;
        z-index: 1000;
        pointer-events: none;
        transform: translateY(-100%);
    }

    .tooltip-content {
        background: rgba(10, 10, 10, 0.95);
        border: 1px solid #e59345;
        border-radius: 6px;
        padding: 10px 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        min-width: 200px;
        max-width: 300px;
    }

    .tooltip-header {
        font-weight: bold;
        font-size: 14px;
        color: #e59345;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(229, 147, 69, 0.3);
    }

    .tooltip-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        font-size: 12px;
    }

    .tooltip-row:last-child {
        margin-bottom: 0;
    }

    .tooltip-label {
        color: #b0b0b0;
        margin-right: 12px;
    }

    .tooltip-value {
        color: #f5f5f5;
        font-weight: 500;
        text-align: right;
    }
</style>


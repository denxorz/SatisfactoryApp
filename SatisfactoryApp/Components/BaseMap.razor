@using Denxorz.Satisfactory.Routes.Types
@using Microsoft.JSInterop
@using MudBlazor
@using SatisfactoryApp.Services
@using SatisfactoryApp.Services.Factories
@using SatisfactoryApp.Utils
@using System.Net
@using System.Text
@using System.Globalization
@implements IDisposable
@inject FactoryStore FactoryStore
@inject LoadedFileStore LoadedFileStore
@inject IJSRuntime JSRuntime
@typeparam T where T : class

<MudCard Outlined="true" Square="true" Class="border-solid border-4 mud-border-primary">
    <MudCardHeader Class="mud-primary pa-0 pl-1">
        <MudText Class="primary-card-header-title" Color="Color.Surface">@Title</MudText>
        @if (!string.IsNullOrEmpty(_error))
        {
            <MudText Typo="Typo.caption" Class="text-uppercase" Color="Color.Error">Error: @_error</MudText>
        }
        @TitleAfterSlot
        <MudIconButton Icon="@MudBlazor.FontIcons.MaterialSymbols.Outlined.MagnifyFullscreen"
                       Color="Color.Tertiary"
                       Size="Size.Small"
                       OnClick="OpenFullscreenDialog"
                       Class="ml-auto" />
    </MudCardHeader>
    <MudCardContent Class="pa-0">
        <div class="map-container @_containerCssClass" onclick="@HandleMapClick">
            <div class="map-wrapper @_wrapperCssClass">
                <img src="/images/1920px-Biome_Map.jpg" alt="Satisfactory Map" class="map-image background-only" draggable="false" />

                @foreach (var l in generatedLayers.Where(s => s.Key.IsVisible && !string.IsNullOrEmpty(s.Value)))
                {
                    <div class="map-svg-overlay @l.Key.Class">
                        @((MarkupString)l.Value)
                    </div>
                }
            </div>

            <div class="map-watermark-overlay">
                @((MarkupString)CreateWatermarkSvg(30))
            </div>

            <div class="legend-overlay">
                @LegendSlot
            </div>

            @if (_showTooltip && _selected != null)
            {
                <div class="factory-tooltip" style="left: @(_tooltipX)px; top: @(_tooltipY)px">
                    <div class="tooltip-content">
                        @TooltipSlot
                    </div>
                </div>
            }
        </div>
    </MudCardContent>
</MudCard>

<MudDialog @bind-Visible="_showFullscreenDialog" Options="@(new DialogOptions { FullScreen = true, CloseButton = true, CloseOnEscapeKey = true })">
    <DialogContent>
        <div class="map-container @_fullscreenContainerCssClass" onclick="@HandleFullscreenMapClick">
            <div class="map-wrapper @_fullscreenWrapperCssClass">
                @if (_fullscreenInitialized)
                {
                    <img src="/images/1920px-Biome_Map.jpg" alt="Satisfactory Map" class="map-image background-only" draggable="false" />

                    @foreach (var l in generatedFullscreenLayers.Where(s => s.Key.IsVisible && !string.IsNullOrEmpty(s.Value)))
                    {
                        <div class="map-svg-overlay @l.Key.Class">
                            @((MarkupString)l.Value)
                        </div>
                    }
                }
            </div>

            @if (_fullscreenInitialized)
            {
                <div class="map-watermark-overlay">
                    @((MarkupString)CreateWatermarkSvg(100))
                </div>
            }

            <div class="legend-overlay">
                @LegendSlot
            </div>

            @if (_showTooltip && _selected != null)
            {
                <div class="factory-tooltip" style="left: @(_tooltipX)px; top: @(_tooltipY)px">
                    <div class="tooltip-content">
                        @TooltipSlot
                    </div>
                </div>
            }
        </div>
    </DialogContent>
</MudDialog>

@code {
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public Func<string, T, string, string> CreateEdge { get; set; } = (fId, f, pos) => "";
    [Parameter] public Action<T?>? SelectedChanged { get; set; }

    [Parameter] public List<IMapLayer<T>> Layers { get; set; } = [];

    [Parameter] public RenderFragment? TitleAfterSlot { get; set; }
    [Parameter] public RenderFragment? OverlaySlot { get; set; }
    [Parameter] public RenderFragment? LegendSlot { get; set; }
    [Parameter] public RenderFragment? TooltipSlot { get; set; }

    private bool _isLoading;
    private string? _error;
    private T? _selected;
    private int _lastUpdateCounter = -1;
    private readonly string _wrapperCssClass = $"map-wrapper-{Guid.NewGuid():N}";
    private readonly string _containerCssClass = $"map-container-{Guid.NewGuid():N}";
    private readonly string _fullscreenWrapperCssClass = $"map-wrapper-fullscreen-{Guid.NewGuid():N}";
    private readonly string _fullscreenContainerCssClass = $"map-container-fullscreen-{Guid.NewGuid():N}";
    private bool _fullscreenInitialized = false;
    private bool _fullscreenNeedsRender = false;
    private bool _fullscreenLoading = false;
    private bool _mapInteractionsInitialized = false;
    private bool _fullscreenInteractionsInitialized = false;
    private bool _showTooltip = false;
    private double _tooltipX = 0;
    private double _tooltipY = 0;
    private bool _showFullscreenDialog = false;

    private Action? _checkAndRenderHandler;
    private CancellationTokenSource? _renderCts;
    private CancellationTokenSource? _fullscreenRenderCts;
    private int _pendingUpdateCounter = -1;
    private int _pendingFullscreenUpdateCounter = -1;
    private const int RenderDebounceMs = 150;

    private const int minX = -320000;
    private const int maxX = 425000;
    private const int minY = -380000;
    private const int maxY = 375000;

    private Dictionary<IMapLayer<T>, string> generatedLayers = [];
    private Dictionary<IMapLayer<T>, string> generatedFullscreenLayers = [];
    private int _lastFullscreenUpdateCounter = -1;

    protected override void OnInitialized()
    {
        _checkAndRenderHandler = () => _ = CheckAndRenderIfNeeded();
        FactoryStore.FilteredFactoriesChanged += _checkAndRenderHandler;
        LoadedFileStore.LoadedFileNameChanged += OnLoadedFileNameChanged;
    }

    public void Dispose()
    {
        FactoryStore.FilteredFactoriesChanged -= _checkAndRenderHandler;
        LoadedFileStore.LoadedFileNameChanged -= OnLoadedFileNameChanged;
        _renderCts?.Cancel();
        _renderCts?.Dispose();
        _fullscreenRenderCts?.Cancel();
        _fullscreenRenderCts?.Dispose();
        _ = JSRuntime.InvokeVoidAsync("disposeMapZoomPan", $".{_containerCssClass}");
        _ = JSRuntime.InvokeVoidAsync("disposeMapZoomPan", $".{_fullscreenContainerCssClass}");
    }

    private void OnLoadedFileNameChanged()
    {
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_mapInteractionsInitialized)
        {
            _mapInteractionsInitialized = await InitializeMapInteractionsAsync(_containerCssClass, _wrapperCssClass);
        }

        if (_showFullscreenDialog && !_fullscreenInteractionsInitialized)
        {
            _fullscreenInteractionsInitialized = await InitializeMapInteractionsAsync(_fullscreenContainerCssClass, _fullscreenWrapperCssClass);
        }

        await CheckAndRenderIfNeeded();
    }

    private async Task<bool> InitializeMapInteractionsAsync(string containerCssClass, string wrapperCssClass)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync(
                "initMapZoomPan",
                $".{containerCssClass}",
                $".{wrapperCssClass}",
                new
                {
                    minScale = 1.0,
                    maxScale = 5.0,
                    startScale = 1.0
                });
            return true;
        }
        catch (Exception ex)
        {
            _error = $"Failed to initialize map interactions: {ex.Message}";
            Console.WriteLine(_error);
            return false;
        }
    }

    private async Task CheckAndRenderIfNeeded()
    {
        if (FactoryStore.UpdateCounter != _lastUpdateCounter)
        {
            _pendingUpdateCounter = FactoryStore.UpdateCounter;
            if (FactoryStore.Factories.Count > 0 && !_isLoading && string.IsNullOrEmpty(_error))
            {
                _ = QueueRenderMapAsync();
            }
        }

        if (_fullscreenInitialized
            && (_fullscreenNeedsRender || FactoryStore.UpdateCounter != _lastFullscreenUpdateCounter)
            && FactoryStore.Factories.Count > 0
            && !_fullscreenLoading
            && string.IsNullOrEmpty(_error))
        {
            _pendingFullscreenUpdateCounter = FactoryStore.UpdateCounter;
            _fullscreenNeedsRender = false;
            _ = QueueRenderFullscreenMapAsync();
        }
    }

    private async Task QueueRenderMapAsync()
    {
        await (_renderCts?.CancelAsync() ?? Task.CompletedTask);
        _renderCts?.Dispose();
        _renderCts = new CancellationTokenSource();

        var token = _renderCts.Token;
        try
        {
            await Task.Delay(RenderDebounceMs, token);
            if (!token.IsCancellationRequested)
            {
                await RenderMap();
            }
        }
        catch (TaskCanceledException)
        {
        }
    }

    private async Task QueueRenderFullscreenMapAsync()
    {
        await (_fullscreenRenderCts?.CancelAsync() ?? Task.CompletedTask);
        _fullscreenRenderCts?.Dispose();
        _fullscreenRenderCts = new CancellationTokenSource();

        var token = _fullscreenRenderCts.Token;
        try
        {
            await Task.Delay(RenderDebounceMs, token);
            if (!token.IsCancellationRequested)
            {
                await RenderFullscreenMap();
            }
        }
        catch (TaskCanceledException)
        {
        }
    }

    private Task<(IMapLayer<T> layer, string svg)> CreateSvgAsync(IMapLayer<T> layer, int mapSize)
    {
        try
        {
            var svg = CreateSvgContent(layer, mapSize);
            return Task.FromResult((layer, svg));
        }
        catch (Exception ex)
        {
            _error = $"Failed to render map layer: {ex.Message}";
            Console.WriteLine(_error);
        }

        return Task.FromResult((layer, ""));
    }

    private async Task RenderMap()
    {
        try
        {
            _isLoading = true;

            var visibleLayers = Layers.Where(l => l.IsVisible).ToList();
            generatedLayers = (await Task.WhenAll(visibleLayers.Select(l => CreateSvgAsync(l, 30))))
                .ToDictionary(l => l.layer, l => l.svg);
        }
        catch (Exception ex)
        {
            _error = "Failed to render graph: " + ex.Message;
            Console.WriteLine(_error);
        }
        finally
        {
            _isLoading = false;
            _lastUpdateCounter = _pendingUpdateCounter;
            StateHasChanged();
        }
    }

    private async Task RenderFullscreenMap()
    {
        Console.WriteLine("Rendering fullscreen map...");
        try
        {
            _fullscreenLoading = true;
            var visibleLayers = Layers.Where(l => l.IsVisible).ToList();
            generatedFullscreenLayers = (await Task.WhenAll(visibleLayers.Select(l => CreateSvgAsync(l, 100))))
                .ToDictionary(l => l.layer, l => l.svg);
        }
        catch (Exception ex)
        {
            _error = "Failed to render graph: " + ex.Message;
            Console.WriteLine(_error);
        }
        finally
        {
            _fullscreenLoading = false;
            _lastFullscreenUpdateCounter = _pendingFullscreenUpdateCounter;
            StateHasChanged();
        }
    }

    private string CreateSvgContent(IMapLayer<T> layer, int mapSize = 30)
    {
        int mapWidth = mapSize;
        int mapHeight = mapSize;
        float mapWidthClamp = mapWidth - 0.1f;
        float mapHeightClamp = mapHeight - 0.1f;

        var scaleX = mapWidth / (float)(maxX - minX);
        var scaleY = mapHeight / (float)(maxY - minY);

        var svg = new StringBuilder();
        svg.AppendLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 {mapWidth} {mapHeight}\" preserveAspectRatio=\"none\">");
        svg.AppendLine("<g fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">");

        (double x, double y) GetPosition(float x, float y)
        {
            var scaledX = (x - minX) * scaleX;
            var scaledY = (y - minY) * scaleY;
            var clampedX = Math.Clamp(scaledX, 0, mapWidthClamp);
            var clampedY = Math.Clamp(scaledY, 0, mapHeightClamp);
            return (clampedX, clampedY);
        }

        var elements = layer.CreateSvgElements(GetPosition);
        elements.ForEach(element => svg.AppendLine(element));

        svg.AppendLine("</g>");
        svg.AppendLine("</svg>");
        return svg.ToString();
    }

    private string CreateWatermarkSvg(int mapSize)
    {
        var watermarkText = $"{DateTime.Now:yyyy-MM-dd HH:mm} • Statisfactory.net • {(!string.IsNullOrWhiteSpace(LoadedFileStore.LoadedFileName) ? LoadedFileStore.LoadedFileName : "No file loaded")}";
        var encodedText = WebUtility.HtmlEncode(watermarkText);
        var fontSize = mapSize / 70.0;
        var x = mapSize * 0.02;
        var y = mapSize * 0.02;

        return string.Format(
            CultureInfo.InvariantCulture,
            "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 {0} {0}\" preserveAspectRatio=\"none\" overflow=\"visible\">" +
            "<text x=\"{1}\" y=\"{2}\" fill=\"rgba(245, 245, 245, 0.02)\" font-size=\"{3}\" font-weight=\"600\" letter-spacing=\"0.08em\">{4}</text>" +
            "</svg>",
            mapSize,
            x,
            y,
            fontSize,
            encodedText);
    }

    private async Task HandleMapClick(MouseEventArgs e)
    {
        await HandleMapClickInternal(e, _wrapperCssClass, _containerCssClass);
    }

    private async Task HandleFullscreenMapClick(MouseEventArgs e)
    {
        await HandleMapClickInternal(e, _fullscreenWrapperCssClass, _fullscreenContainerCssClass);
    }

    private async Task HandleMapClickInternal(MouseEventArgs e, string wrapperCssClass, string containerCssClass)
    {
        var ignoreClick = await JSRuntime.InvokeAsync<bool>("shouldIgnoreMapClick", $".{containerCssClass}");
        if (ignoreClick)
        {
            _showTooltip = false;
            StateHasChanged();
            return;
        }

        var availableItems = Layers
            .Where(l => l.IsVisible)
            .SelectMany(layer => layer.ItemsWithTooltip())
            .ToList();

        var mapPoint = await JSRuntime.InvokeAsync<MapPointResult>(
            "getMapPoint",
            $".{containerCssClass}",
            $".{wrapperCssClass}",
            e.ClientX,
            e.ClientY);
        if (mapPoint == null || mapPoint.Width <= 0 || mapPoint.Height <= 0) return;

        var scaleX = (maxX - minX) / mapPoint.Width;
        var scaleY = (maxY - minY) / mapPoint.Height;

        var scaledClickX = mapPoint.X * scaleX + minX;
        var scaledClickY = mapPoint.Y * scaleY + minY;

        const int clickRadius = 3000;
        T? closest = default;
        double closestDistance = double.MaxValue;

        foreach (var location in availableItems)
        {
            var distance = Math.Sqrt(Math.Pow(scaledClickX - location.X, 2) + Math.Pow(scaledClickY - location.Y, 2));
            if (distance < clickRadius && distance < closestDistance)
            {
                closestDistance = distance;
                closest = location.Item;
            }
        }

        _selected = closest;
        SelectedChanged?.Invoke(_selected);

        if (_selected != null)
        {
            var containerRect = await JSRuntime.InvokeAsync<BoundingClientRect>("getElementBoundingClientRect", $".{containerCssClass}");
            if (containerRect != null)
            {
                var containerClickX = e.ClientX - containerRect.Left;
                var containerClickY = e.ClientY - containerRect.Top;

                var rawX = containerClickX + 15;
                var rawY = containerClickY - 10;

                const double margin = 8;
                const double tooltipWidth = 260;
                const double tooltipHeight = 120;

                var maxTooltipX = Math.Max(margin, containerRect.Width - tooltipWidth - margin);
                var maxTooltipY = Math.Max(margin, containerRect.Height - tooltipHeight - margin);
                var minTooltipY = margin + tooltipHeight;

                _tooltipX = Math.Min(Math.Max(rawX, margin), maxTooltipX);
                _tooltipY = Math.Min(Math.Max(rawY, minTooltipY), maxTooltipY);
                _showTooltip = true;
            }
        }
        else
        {
            _showTooltip = false;
        }

        StateHasChanged();
    }

    private async Task OpenFullscreenDialog()
    {
        _showFullscreenDialog = true;
        if (!_fullscreenInitialized)
        {
            _fullscreenInitialized = true;
            _fullscreenNeedsRender = true;
        }

        await CheckAndRenderIfNeeded();
    }

    private class BoundingClientRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class MapPointResult
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .map-container {
        position: relative;
        overflow: hidden;
        min-height: 400px;
        cursor: grab;
        user-select: none;
        touch-action: none;
    }

    .map-container-fullscreen {
        height: 100%;
        min-height: 100vh;
    }

    .map-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        transform-origin: 0 0;
        -webkit-user-drag: none;
    }

    .map-container.map-dragging {
        cursor: grabbing;
    }

    .map-image {
        object-fit: contain;
        transition: opacity 0.2s;
        width: 100%;
        height: auto;
        -webkit-user-drag: none;
    }

        .map-image.background-only {
            filter: grayscale(0.4) contrast(0.8) brightness(1.1);
            opacity: 0.4;
        }

    .map-svg-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .map-watermark-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        transform-origin: 0 0;
        transform: translate(var(--map-translate-x, 0px), var(--map-translate-y, 0px)) scale(var(--map-scale, 1));
        z-index: 4;
    }

        .map-svg-overlay svg {
            width: 100%;
            height: 100%;
        }

    .map-svg-overlay .map-icon-marker {
        transform: scale(calc(1 / var(--map-scale, 1)));
    }

    .map-svg-overlay-filtered {
        opacity: 0.3;
    }

    .legend-overlay {
        position: absolute;
        bottom: 16px;
        right: 16px;
        background: var(--mud-palette-surface);
        border: 1px solid #e59345;
        border-radius: 6px;
        padding: 8px 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 170px;
        backdrop-filter: blur(4px);
        z-index: 10;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #f5f5f5;
    }

    .legend-icon {
        display: inline-block;
    }

    .factory-tooltip {
        position: absolute;
        z-index: 1000;
        pointer-events: none;
        transform: translateY(-100%);
    }

    .tooltip-content {
        background: rgba(10, 10, 10, 0.95);
        border: 1px solid #e59345;
        border-radius: 6px;
        padding: 10px 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        min-width: 200px;
        max-width: 300px;
    }

    .tooltip-header {
        font-weight: bold;
        font-size: 14px;
        color: #e59345;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(229, 147, 69, 0.3);
    }

    .tooltip-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        font-size: 12px;
    }

        .tooltip-row:last-child {
            margin-bottom: 0;
        }

    .tooltip-label {
        color: #b0b0b0;
        margin-right: 12px;
    }

    .tooltip-value {
        color: #f5f5f5;
        font-weight: 500;
        text-align: right;
    }
</style>

